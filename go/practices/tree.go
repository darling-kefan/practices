// 树t是一个非空的有限元素的集合，其中一个为根，余下的元素组成t的子树
//
// 二叉树：二叉树(binary tree)是有限个元素的集合(可以为空)。当二叉树非空时，其中有一个
// 称为根的元素，余下的元素被组成2个二叉树，分别为t的左子树和右子树。
//
// 二叉树和树的区别：
// . 二叉树可以为空，树不能为空
// . 二叉树中每个元素都恰好有两颗子树(其中一个或两个可能为空)。而树中每个元素可以有若干子树
// . 在二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子树来区别。而树的子树是无序的
//
// 二叉树的特性：
// 特性1： 包含n(n>0)个元素的二叉树边数是n-1
// 证明二叉树中每个元素(除了根节点)有且只有一个父节点。在子节点和父节点间有且只有一条边，因此边数为n-1
// 二叉树的高度或者深度是指该二叉树的层数。
//
// 特性2： 若二叉树的高度为h，h>=0，则该二叉树最少有h个元素，最多有2h-1个元素。
//
// 特性3: 包含n个元素的二叉树的高度最大是n，最小是log2(n+1)向上取整
//
// 当高度是h的二叉树恰好有2h-1个元素时，称其是满二叉树(full binary tree)。
//
// 假设从满二叉树中删除k个元素，其编号为2h-i, 1<=i<=k，所得到的二叉树称为完全二叉树(complete binary tree)。满二叉树是完全二叉树的一个特例，并且有n个元素的完全二叉树的深度log2(n+1)向上取整
//
// 在完全二叉树中，一个元素与其孩子的编号有非常好的对应关系。
// 特性4： 设完全二叉树中一元素的序号是i，1<=i<=n。则有以下关系成立：
// 1) 当i=1时，该元素为二叉树的根，若i>1，则该元素父节点的编号是i/2向下取整
// 2) 当2i>n时，该元素没有左子树，否则，其左子树的编号是2i。
// 3) 若2i+1>n时，该元素没有右子树，否则，其右子树的编号是2i+1。
//
// 二叉树描述
// 一. 公式化描述
// 二叉树的描述利用特性4.二叉树可以作为缺少了部分元素的完全二叉树。在公式化描述方法中，按照二叉树中元素的编号，将二叉树存储在数组中。
//
// 二. 链表描述
// 二叉树最常用的描述方法是用链表或指针。每个元素都用一个有两个指针域的节点表示，这两个域是LeftChild和RightChild。除此两个指针域外，每个节点还有一个data域。

package main

import (
	"fmt"
	"math"
)

type fullBinaryTree []int

// 公式化描述二叉树方式只适合少量数据
// var fbt fullBinaryTree = []int{75, 95, 64, 17, 47, 0, 0, 0, 82, 18, 35, 0, 0, 0, 87, 0, 0, 0, 10, 20, 4, 0, 0, 0, 82, 0, 0, 0, 47, 0, 0, 0, 65, 19, 1, 0, 0, 0, 23, 0, 0, 0, 75, 0, 0, 0, 3, 0, 0, 0, 34, 88, 2, 0, 0, 0, 77, 0, 0, 0, 73, 0, 0, 0, 7, 0, 0, 0, 63, 0, 0, 0, 67, 99, 65, 0, 0, 0, 4, 0, 0, 0, 28, 0, 0, 0, 6, 0, 0, 0, 16, 0, 0, 0, 70, 0, 0, 0, 92, 41, 41, 0, 0, 0, 26, 0, 0, 0, 56, 0, 0, 0, 83, 0, 0, 0, 40, 0, 0, 0, 80, 0, 0, 0, 70, 0, 0, 0, 33, 41, 48, 0, 0, 0, 72, 0, 0, 0, 33, 0, 0, 0, 47, 0, 0, 0, 32, 0, 0, 0, 37, 0, 0, 0, 16, 0, 0, 0, 94, 0, 0, 0, 29, 53, 71, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 65, 0, 0, 0, 25, 0, 0, 0, 43, 0, 0, 0, 91, 0, 0, 0, 52, 0, 0, 0, 97, 0, 0, 0, 51, 0, 0, 0, 14, 70, 11, 0, 0, 0, 33, 0, 0, 0, 28, 0, 0, 0, 77, 0, 0, 0, 73, 0, 0, 0, 17, 0, 0, 0, 78, 0, 0, 0, 39, 0, 0, 0, 68, 0, 0, 0, 17, 0, 0, 0, 57, 91, 71, 0, 0, 0, 52, 0, 0, 0, 38, 0, 0, 0, 17, 0, 0, 0, 14, 0, 0, 0, 91, 0, 0, 0, 43, 0, 0, 0, 58, 0, 0, 0, 50, 0, 0, 0, 27, 0, 0, 0, 29, 0, 0, 0, 48, 63, 66, 0, 0, 0, 4, 0, 0, 0, 68, 0, 0, 0, 89, 0, 0, 0, 53, 0, 0, 0, 67, 0, 0, 0, 30, 0, 0, 0, 73, 0, 0, 0, 16, 0, 0, 0, 69, 0, 0, 0, 87, 0, 0, 0, 40, 0, 0, 0, 31, 4, 62, 0, 0, 0, 98, 0, 0, 0, 27, 0, 0, 0, 23, 0, 0, 0, 9, 0, 0, 0, 70, 0, 0, 0, 98, 0, 0, 0, 73, 0, 0, 0, 93, 0, 0, 0, 38, 0, 0, 0, 53, 0, 0, 0, 60, 0, 0, 0, 4, 0, 0, 0, 23}

var fbt fullBinaryTree = []int{3, 7, 4, 2, 4, 0, 6, 8, 5, 0, 9, 0, 0, 0, 3}

type tree interface {
	Size() int
	Height() int
}

func (fbt fullBinaryTree) Size() int {
	return len(fbt)
}

func (fbt fullBinaryTree) Height() int {
	return int(math.Ceil(math.Log2(float64(fbt.Size() + 1))))
}

var paths [][]int

// 计算路径
// 注意：slice传递的是一个引用
func preOrder(i int, l int, list []int) {
	list = append(list, i)

	// 如果该节点是叶子节点，则产生一条路径
	if 2*i >= l {
		// copy slice
		copyList := make([]int, len(list))
		copy(copyList, list)
		paths = append(paths, copyList)
		// 函数返回时，将本节点元素删除
		list = list[:len(list)-1]
		return
	}
	// 左子树
	preOrder(2*i, l, list)
	// 右子树
	preOrder(2*i+1, l, list)

	// 函数返回时，将本节点元素删除
	list = list[:len(list)-1]
}

func main() {
	fmt.Println(fbt)
	fmt.Println(math.Log2(float64(fbt.Size() + 1)))
	fmt.Printf("%T %v\n", fbt.Size(), fbt.Size())
	fmt.Printf("%T %v\n", fbt.Height(), fbt.Height())

	var list []int
	preOrder(1, fbt.Size(), list)

	maxSum := 0
	for _, path := range paths {
		sum := 0
		for _, i := range path {
			sum += fbt[i-1]
		}
		if sum > maxSum {
			maxSum = sum
			fmt.Println(path)
		}
	}

	fmt.Println(maxSum)
}
